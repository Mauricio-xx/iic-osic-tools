#!/bin/bash
# ========================================================================
# iic-testcase-compare - Output Comparison Utility for IHP-EDA-Tools
#
# SPDX-FileCopyrightText: 2025 IHP-EDA-Tools Contributors
# SPDX-License-Identifier: Apache-2.0
#
# Usage: iic-testcase-compare <method> [options] <file1> [file2]
#
# Methods:
#   exists      Check if file exists
#   checksum    Compare file checksums (MD5 or SHA256)
#   pattern     Search for patterns in text file
#   numerical   Compare numerical values with tolerance
# ========================================================================

set -e

VERSION="1.0.0"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ========================================================================
# Helper functions
# ========================================================================

print_usage() {
    cat << EOF
iic-testcase-compare - Output Comparison Utility v$VERSION

Usage: iic-testcase-compare <method> [options] <file1> [file2]

Methods:
  exists <file>                         Check if file exists
    --min-size <bytes>                  Minimum file size

  checksum <file1> <file2>              Compare file checksums
    --algorithm <md5|sha256>            Hash algorithm (default: md5)

  pattern <file> [options]              Search for patterns in text
    --must-contain <pattern>            Pattern that must exist (can repeat)
    --must-not-contain <pattern>        Pattern that must not exist (can repeat)
    --ignore-case                       Case-insensitive matching

  numerical <file1> <file2>             Compare numerical values
    --tolerance <value>                 Absolute tolerance (default: 0.001)
    --relative-tolerance <value>        Relative tolerance (percentage)
    --column <n>                        Compare specific column only

Options:
  -h, --help                            Show this help message
  -v, --version                         Show version
  -q, --quiet                           Suppress informational output

Exit codes:
  0  Comparison passed
  1  Comparison failed
  2  Error (missing file, invalid arguments, etc.)

Examples:
  iic-testcase-compare exists output.gds --min-size 1000
  iic-testcase-compare checksum output.raw expected.raw
  iic-testcase-compare pattern sim.log --must-contain "success" --must-not-contain "error"
  iic-testcase-compare numerical results.csv expected.csv --tolerance 0.01

EOF
}

print_version() {
    echo "iic-testcase-compare version $VERSION"
}

log_info() {
    [ -z "$QUIET" ] && echo -e "${BLUE}[INFO]${NC} $1"
}

log_pass() {
    echo -e "${GREEN}[PASS]${NC} $1"
}

log_fail() {
    echo -e "${RED}[FAIL]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

# ========================================================================
# Method: exists
# ========================================================================

method_exists() {
    local file=""
    local min_size=0

    while [ $# -gt 0 ]; do
        case "$1" in
            --min-size) min_size="$2"; shift 2 ;;
            -*) shift ;;
            *) file="$1"; shift ;;
        esac
    done

    if [ -z "$file" ]; then
        log_fail "No file specified"
        return 2
    fi

    if [ ! -e "$file" ]; then
        log_fail "File does not exist: $file"
        return 1
    fi

    if [ ! -f "$file" ]; then
        log_fail "Not a regular file: $file"
        return 1
    fi

    local actual_size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)

    if [ "$min_size" -gt 0 ] && [ "$actual_size" -lt "$min_size" ]; then
        log_fail "File too small: $actual_size bytes (minimum: $min_size)"
        return 1
    fi

    log_pass "File exists: $file ($actual_size bytes)"
    return 0
}

# ========================================================================
# Method: checksum
# ========================================================================

method_checksum() {
    local file1=""
    local file2=""
    local algorithm="md5"

    while [ $# -gt 0 ]; do
        case "$1" in
            --algorithm) algorithm="$2"; shift 2 ;;
            -*) shift ;;
            *)
                if [ -z "$file1" ]; then
                    file1="$1"
                else
                    file2="$1"
                fi
                shift
                ;;
        esac
    done

    if [ -z "$file1" ] || [ -z "$file2" ]; then
        log_fail "Two files required for checksum comparison"
        return 2
    fi

    if [ ! -f "$file1" ]; then
        log_fail "File not found: $file1"
        return 2
    fi

    if [ ! -f "$file2" ]; then
        log_fail "File not found: $file2"
        return 2
    fi

    local hash1 hash2

    case "$algorithm" in
        md5)
            hash1=$(md5sum "$file1" 2>/dev/null | awk '{print $1}')
            hash2=$(md5sum "$file2" 2>/dev/null | awk '{print $1}')
            ;;
        sha256)
            hash1=$(sha256sum "$file1" 2>/dev/null | awk '{print $1}')
            hash2=$(sha256sum "$file2" 2>/dev/null | awk '{print $1}')
            ;;
        *)
            log_fail "Unknown algorithm: $algorithm (use md5 or sha256)"
            return 2
            ;;
    esac

    if [ "$hash1" = "$hash2" ]; then
        log_pass "Checksums match ($algorithm: ${hash1:0:16}...)"
        return 0
    else
        log_fail "Checksums differ"
        log_info "  File 1: $hash1"
        log_info "  File 2: $hash2"
        return 1
    fi
}

# ========================================================================
# Method: pattern
# ========================================================================

method_pattern() {
    local file=""
    local must_contain=()
    local must_not_contain=()
    local ignore_case=""

    while [ $# -gt 0 ]; do
        case "$1" in
            --must-contain) must_contain+=("$2"); shift 2 ;;
            --must-not-contain) must_not_contain+=("$2"); shift 2 ;;
            --ignore-case) ignore_case="-i"; shift ;;
            -*) shift ;;
            *) file="$1"; shift ;;
        esac
    done

    if [ -z "$file" ]; then
        log_fail "No file specified"
        return 2
    fi

    if [ ! -f "$file" ]; then
        log_fail "File not found: $file"
        return 2
    fi

    local failed=0

    # Check must_contain patterns
    for pattern in "${must_contain[@]}"; do
        if grep -q $ignore_case "$pattern" "$file" 2>/dev/null; then
            log_pass "Found required pattern: '$pattern'"
        else
            log_fail "Missing required pattern: '$pattern'"
            failed=1
        fi
    done

    # Check must_not_contain patterns
    for pattern in "${must_not_contain[@]}"; do
        if grep -q $ignore_case "$pattern" "$file" 2>/dev/null; then
            log_fail "Found forbidden pattern: '$pattern'"
            # Show context
            grep -n $ignore_case "$pattern" "$file" 2>/dev/null | head -3 | while read -r line; do
                log_info "  $line"
            done
            failed=1
        else
            log_pass "Correctly absent: '$pattern'"
        fi
    done

    return $failed
}

# ========================================================================
# Method: numerical
# ========================================================================

method_numerical() {
    local file1=""
    local file2=""
    local tolerance="0.001"
    local relative_tolerance=""
    local column=""

    while [ $# -gt 0 ]; do
        case "$1" in
            --tolerance) tolerance="$2"; shift 2 ;;
            --relative-tolerance) relative_tolerance="$2"; shift 2 ;;
            --column) column="$2"; shift 2 ;;
            -*) shift ;;
            *)
                if [ -z "$file1" ]; then
                    file1="$1"
                else
                    file2="$1"
                fi
                shift
                ;;
        esac
    done

    if [ -z "$file1" ] || [ -z "$file2" ]; then
        log_fail "Two files required for numerical comparison"
        return 2
    fi

    if [ ! -f "$file1" ]; then
        log_fail "File not found: $file1"
        return 2
    fi

    if [ ! -f "$file2" ]; then
        log_fail "File not found: $file2"
        return 2
    fi

    # Use awk for numerical comparison
    local result
    result=$(awk -v tol="$tolerance" -v rel_tol="$relative_tolerance" -v col="$column" '
    BEGIN {
        errors = 0
        max_diff = 0
        compared = 0
    }

    FNR == NR {
        # Store file1 values
        if (col != "") {
            values1[FNR] = $col
        } else {
            for (i = 1; i <= NF; i++) {
                if ($i ~ /^-?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/) {
                    values1[FNR "," i] = $i
                }
            }
        }
        lines1 = FNR
        next
    }

    {
        # Compare with file2 values
        if (col != "") {
            v1 = values1[FNR]
            v2 = $col
            if (v1 != "" && v2 != "") {
                diff = (v1 > v2) ? v1 - v2 : v2 - v1
                if (rel_tol != "") {
                    ref = (v1 > v2) ? v1 : v2
                    if (ref != 0) {
                        rel_diff = diff / ref * 100
                        if (rel_diff > rel_tol) {
                            errors++
                            if (errors <= 5) {
                                print "Line " FNR ": " v1 " vs " v2 " (diff: " rel_diff "%)"
                            }
                        }
                    }
                } else {
                    if (diff > tol) {
                        errors++
                        if (errors <= 5) {
                            print "Line " FNR ": " v1 " vs " v2 " (diff: " diff ")"
                        }
                    }
                }
                if (diff > max_diff) max_diff = diff
                compared++
            }
        } else {
            for (i = 1; i <= NF; i++) {
                if ($i ~ /^-?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/) {
                    v1 = values1[FNR "," i]
                    v2 = $i
                    if (v1 != "") {
                        diff = (v1 > v2) ? v1 - v2 : v2 - v1
                        if (diff > tol) {
                            errors++
                            if (errors <= 5) {
                                print "Line " FNR " col " i ": " v1 " vs " v2 " (diff: " diff ")"
                            }
                        }
                        if (diff > max_diff) max_diff = diff
                        compared++
                    }
                }
            }
        }
    }

    END {
        print "SUMMARY:" errors ":" compared ":" max_diff
    }
    ' "$file1" "$file2")

    # Parse summary
    local summary=$(echo "$result" | grep "^SUMMARY:" | tail -1)
    local errors=$(echo "$summary" | cut -d: -f2)
    local compared=$(echo "$summary" | cut -d: -f3)
    local max_diff=$(echo "$summary" | cut -d: -f4)

    # Show differences (excluding summary)
    echo "$result" | grep -v "^SUMMARY:" | while read -r line; do
        [ -n "$line" ] && log_info "  $line"
    done

    if [ "$errors" -eq 0 ]; then
        log_pass "Numerical comparison passed ($compared values, max diff: $max_diff)"
        return 0
    else
        log_fail "Numerical comparison failed: $errors differences (tolerance: $tolerance)"
        return 1
    fi
}

# ========================================================================
# Main
# ========================================================================

QUIET=""

# Parse global options
while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            print_usage
            exit 0
            ;;
        -v|--version)
            print_version
            exit 0
            ;;
        -q|--quiet)
            QUIET=1
            shift
            ;;
        *)
            break
            ;;
    esac
done

# Get method
METHOD="${1:-}"
shift 2>/dev/null || true

case "$METHOD" in
    exists)
        method_exists "$@"
        ;;
    checksum)
        method_checksum "$@"
        ;;
    pattern)
        method_pattern "$@"
        ;;
    numerical)
        method_numerical "$@"
        ;;
    "")
        print_usage
        exit 2
        ;;
    *)
        log_fail "Unknown method: $METHOD"
        echo "Run 'iic-testcase-compare --help' for usage"
        exit 2
        ;;
esac
